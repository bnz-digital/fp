---
title: Variables
trail:
  - label: Home
    href: '/'
  - label: Bottom-up
    href: '/inductive/'
---
import Link from '../../../components/Link'

import Highlighter from '../../../components/Highlighter'
import CodeBlock from '../../../components/CodeBlock'
import assignAtDeclarationSource from '../../../runkits/inductive/assign-at-declaration'
import constSource from '../../../runkits/inductive/const'
import deepFreezeSource from '../../../runkits/inductive/deep-freeze'
import freezeMyButtSource from '../../../runkits/inductive/freeze-my-butt'
import letSource from '../../../runkits/inductive/let'
import restArgsSource from '../../../runkits/inductive/rest-args'
import restArraySource from '../../../runkits/inductive/rest-array'
import restObjectSource from '../../../runkits/inductive/rest-object'
import spreadArraySource from '../../../runkits/inductive/spread-array'
import spreadObjectSource from '../../../runkits/inductive/spread-object'

## Variables are &ldquo;set and forget&rdquo;

One fun "feature" of JavaScript is that variables are not statically typed. That means not only that we can reassign variables or mutate their values, but also that we can change their _type_.

We know what you're thinking! Whoa, that's insane, right? But we kid you not, JavaScript actually considers this a _feature_. Go figure.

Here is an example: We could declare a variable with `let`, then later assign a number as its value, and then later still assign a string to the same variable:

<CodeBlock {...letSource} />

If you were looking for an effective way to create **hard-to-find bugs** in your code, you'd be hard-pressed to find a better one. If variables can change not only value, but also **type**, then how can you be sure what the value or type of _any_ variable is anywhere in your code?

In short, if you enjoy chasing down bugs due to unexpected mutations&mdash;have fun with that!&mdash;then `let` and mutability are for you!

In functional JavaScript, we **assign values when they are declared**, then we never change them. No, really. _Never_.

How do we manage this? Read on.

### <span id='use-const-exclusively'>Use <code>const</code> exclusively!</span>

As a start, we prevent variables from being reassigned. We do this with `const`, a misnamed keyword. It is misnamed because it does not actually create a constant, but only prevents _reassingment_. More on this below.

Here is `const` in action. Note: there is never a good reason to use `let` or, heaven forbid, `var` in your applications. (If you're building a library, on the other hand, then let's talk.)

<CodeBlock {...constSource} />

### <span id='assign-upon-declaration'>Assign variables when they are declared</span>

We said that `const` can't be reassigned, so if we declare it without assigning a value, then we're stuck. In the real world, JavaScript won't let you do this. So we have to assign the value at the point of declaration:

<CodeBlock {...assignAtDeclarationSource} />

### <span id='never-mutate'>Once a variable has been assigned, don't be changing it</span>

Unreassignable is not the same thing as "immutable" (unchangeable). If a `const` is assigned a complex value, such as an `Array` or `Object`, then it _is_  possible to reach into that complex value and change it _without_ "reassigning" the variable. This is a significant failing of `const` in our opinion. It can give a false sense of security.

JavaScript does offer, however, a way to reach into objects and make them "read-only". Now they really are immutable. Unfortunately, this capability only freezes one level at a time, so to fully "freeze" an object, we have to traverse the entire tree freezing all the levels.

<CodeBlock {...freezeMyButtSource} />

Well, now, ain't that a damn shame.

To make this easier, a few people have written libraries and utility functions. Or we can just write a function that calls itself and traverses the object freezing each level in turn:

<CodeBlock {...deepFreezeSource} />

Unfortunately, these fail to mutate silently rather than throwing an error. Sigh... nothing is perfect.

Truth is that with best practices and making it a habit to keep things immutable, you probably don't need a `freeze` function except in unit tests. In your unit tests, you definitely should ensure that you aren't mutating variables.

### <span id='never-destroy-state'>Don't erase state: create new state instead!</span>

It might not be clear yet, but refusing to change a variable once it has been assigned is actually about preserving state.

Think about it. Suppose I use `let` to create a variable `x` and assign it value `3`. (Don't, but hypothetically...)

Now a bit later, I assign it a new value. Say, `5`. OK, what was the previous value?

You might remember, _but your code doesn't_, because you _overwrote it_. Now why you wanna erase that state? What did it ever do to you?

In functional JavaScript we keep track of state, in general, by making new copies when we want to change something. This means that if I go back to look at the value of `x` for any reason, then it is still `3`. My `newX` is `5`.

This also allows us to set up "time-travel debugging", where we can move a slider back and forth and see how the state of our application changes over time. Often, it means that we can "replay" everything, too. It almost makes debugging fun.

Speaking of state, one of the reasons we keep our variables immutable and our functions "pure" is to avoid sharing state. That's kind of a mantra for functional programmers: _no shared state_. Sharing state is a good way to create difficult-to-find bugs. And it makes parallel processing difficult. When each process is responsible for its own state, life is sweet.

So think about state whenever you write code. After all, every application manages some kind of state. If nothing ever changed, then what would be the point of the app?

### <span id='use-destructuring-to-make-copies'>Use destructuring and the rest/spread operators to make copies</span>

We've shown how we can avoid reassignment of variables by using `const`, and how we can avoid mutation by making copies, and we've mentioned the spread (and rest) syntax. Let's take a closer look at our syntax options.

The **rest** syntax and the **spread** syntax look the same. Both use an ellipsis: `...` So what's the difference? It's fairly simple: the **rest** syntax is used on the _left-hand side_ of an expression, and the **spread** syntax is used on the _right-hand side_.

Check it out:

<CodeBlock {...restArraySource} />

Remember that JavaScript arrays _preserve ordering_. You can think of the left-hand side of the assignment operator as a "pattern" or "mask" for the right-hand side. By placing `x` in the position of the first element of the array, it is assigned the first element of our `[1, 2, 3, 4, 5]` array, which is `1`.

Now we want to scoop up the remaining elements of the array&mdash;the "rest" of them&mdash;and put them in another variable. The custom of using `x` and `xs` for the head and the tail of an array is very common and well understood in functional programming (not just in JavaScript). So we use `...xs` to collect all the remaining elements save the first of `[1, 2, 3, 4, 5]` and put them in an array, which is `[2, 3, 4, 5]`.

We can also use the **rest** syntax to collect key-value pairs from an object:

<Highlighter code={restObjectSource.code} />

Unfortunately, Runkit doesn't support this, but you can copy and paste the above into the Chrome Developer Tools console and see that it works. You should find that there is a variable `colour` with the value 'pink', and a variable `rest` with the value:

<Highlighter code={`{
  food: 'Tiramisu',
  show: 'Game of Throne',
  song: 'Swimming Pools (Drank)'
}`} />

Now let's consider the **spread** syntax. When we use `...` on the right-hand side of the assignment operator, it takes a collection of values&mdash;it could be either an array or an object&mdash;and "spreads" them out into a new array or object.

Here we see the spread syntax in action with an array:

<CodeBlock {...spreadArraySource} />

And here with an object:

<CodeBlock {...spreadObjectSource} />

The ordering is important. As you can see from the code example above, when overwriting, whichever comes _last_, wins.

One other common use for the **rest** syntax is to collect arguments into an array. With the **rest** syntax, the variable name with the `...` _must come last_. It's greedy. If you put it first, it will collect everything and there won't be any left:

<CodeBlock {...restArgsSource} />

The **rest** syntax is also great when destructuring props as they come into a React component. Sadly, Runkit doesn't support this, but try it in the DevTools console:

<Highlighter code={`// Imagine that this is a React component
function example ({ name, ...props }) {
  console.log('name is', name)
  console.log('props is', props)  
}
example({ name: 'Bob', nickname: 'J.R.', seeks: 'slack' })`} />

So useful. Now that we understand how functions provide high <Link to='/inductive/reusability/'>reusability</Link> and variables should be "<Link to='/inductive/immutability/'>set and forget</Link>", let's see how we can <Link to='/inductive/iteration/'>avoid loops</Link>.
