---
title: Patterns and antipatterns
trail:
  - label: Home
    href: '/'
---
import CodeBlock from '../../components/CodeBlock'
import Highlighter from '../../components/Highlighter'
import Link from '../../components/Link'

import badInheritanceSource from '../../runkits/patterns/bad-inheritance'
import compositionByAggregationSource from '../../runkits/patterns/composition-by-aggregation'
import compositionByConcatenationSource from '../../runkits/patterns/composition-by-concatenation'
import compositionByDelegationSource from '../../runkits/patterns/composition-by-delegation'
import utilityFunctionsSource from '../../runkits/patterns/utility-functions'

<ul>
  <li>
    No more Page Objects
  </li>
  <li>
    Enter Page Modules
  </li>
  <li>
    But what about inheritance?
  </li>
  <li>
    Favour composition over inheritance
  </li>
  <li>
    Readability
  </li>
</ul>

<h3 id='no-more-page-objects'>No more Page Objects</h3>

The **Page Object** design pattern offers two benefits:

1. It keeps all page element selectors in one place; thus, it provides separation of test code from the locators of the application under test (AUT).
1. It standardises how tests interact with the page; thus, it avoids duplication of code and eases code maintenance.

Object-orientation (OO) in JavaScript is a bit awkward. Introduction of the `class` keyword in JavaScript 2015 helped, but classes, and specifically the `this` keyword, still surprise people Java programmers because they work very differently.

[Here is a great blog from Kent C. Dodds which highlights this point](https://kentcdodds.com/blog/classes-complexity-and-functional-programming).

<h3 id='enter-page-modules'>Enter Page Modules</h3>

In Java land, it's pretty common to find Page Objects which inherit from the Base Page. In JavaScript, that might look like this:

<Highlighter code={`import { HomePage } from './BasePage'\n
class HomePage extends BasePage  {
  constructor() {
    super();
    this.mainElement = 'body > .banner';
  }
  //... More code\n
  export const mainPage = new MainPage();
}`} theme='dark' />

_With the move to functional programming, we are going to loose not only **inheritance**, but the `class` itself._ Therefore, we need to use **modules** to arrange our code. Each module exports public functions that can be imported into other modules and used:

<Highlighter code={`// In the HomePage module (HomePage.js or HomePage/index.js)
export function login (email, password) {
  //...
}\n
export function logout () {
  //...
}\n
export function search (criterion) {
  // ...
}`} />

This module can then be imported into your tests or other modules and used as below:

<Highlighter code={`// In the HomePageTest module (HomePageTest.js or HomePageTest/index.js)
import * as homePage from './HomePage.js'\n
describe('Home Page', () => {
  it('User can login', () => {
      cy.visit('/')
      homePage.login('prateek', '123456')
  })
})`} />

or we can import individual functions from a module selectively:

<Highlighter code={`import { login } from './HomePage.js'\n
describe('Home Page', () => {
  it('User can login', () => {
    cy.visit('/')
    login('prateek', '123456')
  })
})`} />

In general, import only the functions you need when possible.

<h3 id='but-what-about-inheritance'>But what about inheritance?</h3>

<Highlighter code={`public class HomePage extends BasePage { ... } // Java`} language='java' showLineNumbers={false} />

Often we come across test suites where Page Objects extend a `BasePage` or every test file extends a `BaseTest` class.

The intention behind this is typically code reuse. Most often the `BaseTest` class has methods related to login, logout, logging, etc.

**Please don't do that.** Bundling _unrelated functionality_ into a parent class for the purpose of reuse is an abuse of inheritance.

Common functionality required by **specs** can be added as Cypress **custom commands**. Custom commands are available to be used globally with the `cy.` prefix. For example, we can add a method called `login` using a custom command:

<Highlighter code={`Cypress.Commands.add('login', (username, password) => {
    cy.get('#username').type(username)
    //...
})`} />

The `Cypress.Commands.add` function takes the _name_ of the custom command as the first argument, and a _function_ as the second argument.

Now we can use that name to call the custom command in any spec:

<Highlighter code={`describe('Login Page', () => {
  it('User can login', () => {
    cy.login('prateek', '123456')
    // ...
  })
})`} />

Note: functionality that is shared between a few specs _but not all_ should be added to **utility modules** instead of adding a custom command. Reserve custom commands for widely-used functionality. 

<h3 id='favour-composition-over-inheritance'>&ldquo;Favour composition over inheritance&rdquo;</h3>

Why? Watch this video to find out:

<iframe width="560" height="315" src="https://www.youtube.com/embed/wfMtDGfHWpA" frameBorder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowFullScreen></iframe>

Now, consider the code below that uses **inheritance** (don't do this):

<CodeBlock {...badInheritanceSource} theme='dark' />

Inheritance is actually a form of &ldquo;object composition&rdquo;. It is the form that binds the objects most tightly, hence it is the one to be most avoided, if possible.

Here we are using inheritance to provide for code reuse. There is no separate `Person` object to which `Employee` refers. `Employee` simply inherits the properties (and methods, if any) of the `Person` object, so, for example, the `fullName` getter is available both within `Employee` (as in the `toString` method) and on instances of `Employee`.

The same functionality could be achieved using **composition**. There are three common ways to compose objects in JavaScript: aggregation, delegation, and concatenation.

**Aggregation** preserves the objects that we're composing (aggregating). Here, an `Employee` is simply a wrapper around a `Person` that adds an employee `id` property. A key feature of aggregation is that the `Person` object retains its integrity and we can extract it from the `Employee` object:

<CodeBlock {...compositionByAggregationSource} />

**Delegation** is similar, except we do not inject the `Person` into the `Employee`, so the `Person` is not directly visible in the `Employee` and we can't extract the `Person` back out again as easily.

However, the properties of the `Person` are directly accessible from within the `Employee`, and if we mutate the `Person` (which we won't, right?), then those changes are immediately visible in the `Employee` that delegates to that person.

To pull the `Person` back out, we've got to get it from the prototype: `Object.getPrototypeOf(employee)`.

Delegation can be used to save memory, while making the properties of `Person` _directly_ accessible from within `Employee` (i.e., we don't have to go through the `person` property):

<CodeBlock {...compositionByDelegationSource} />

**Concatenation** is the simplest and often the best for our purposes as we always make copies rather than mutating in place. If we are never going to mutate the `Person` object once we've created it, then why bother linking to it? This is the loosest form of coupling, and should be the first one to which we turn.

Concatenation simply creates a new object, copying the properties from all objects passed:

<CodeBlock {...compositionByConcatenationSource} />

Note: Functions which return objects are called **factory functions**.

In our inheritance example above, `Person` provided a `fullName` getter&mdash;a computed property. The functional way to do this is with a utility function. We could put all our functions used for `Person` in a `Person` module rather than a `Person` class. Then we import that module&mdash;or just the functions we need&mdash;and use them.

<CodeBlock {...utilityFunctionsSource} />

<h3 id='readability'>Readability</h3>

The reason many people give for using Page Objects is that they encapsulate the complexity of the UI and the locators, which helps with reusability and making the tests more readable. But what is the tradeoff? (There is _always_ a tradeoff.) And is there a better way?

Note: For these examples I am using the [Cypress TodoMVC Example Repo](https://github.com/cypress-io/cypress-example-todomvc) and refactoring a few tests.

Consider this typical Cypress example:

<Highlighter code={`describe('Todo Application', () => {
  it('Can add a new Todo', () => {
    cy.get('.new-todo')    // What am I getting here? It's not clear
      .type('First Todo')  // Entering text, so maybe some type of input?
      .type('{enter}')     // Hitting enter, so maybe submitting a form?\n
    cy.get('.todo-list li')            // Some list element
      .eq(0)                           // Not even sure what this is
      .find('label')                    // Has a label element
      .should('contain', 'First Todo') // That should contain this text. Who cares?
  })
})`} theme='dark' />

As you can see, while the _action_ we're undertaking&mdash;`get`, `type`, `eq`, `find`, `should`&mdash;is obvious, what we're actually trying to accomplish is **not clear at all.**.

Contrast that with this equivalent example:

<Highlighter code={`import { addTodo, getTopTodoFromList, getTodoLabel } from './TodoUtil'\n
const TODO_LABEL = 'My Todo'\n
describe('Todo Application', () => {
  it('Can add a new Todo', () => addTodo(TODO_LABEL)
    .then(getTopTodoFromList)
    .then(getTodoLabel)
    .should('equal', TODO_LABEL)
  )
})`} />

The first example is **imperative**. It tells Cypress **how** to execute the test. Our second, better example is **declarative**. We have abstracted away the &ldquo;how&rdquo; and we simply concern ourselves with **what** to do.

Our declarative second example is far more readable, which means much lower cognitive load for the reader: we can understand it at a glance. Even non-technical personnel, such as your business analyst or product owner, can read and understand this test easily. Note also that we no longer need comments to explain what we're doing.

**And we get the added benefit of the reusability of the utility functions `addTodo`, `getTopTodoFromList`, and `getTodoLabel`.**

So where can we find our `addTodo`, `getTopTodoFromList`, and `getTodoLabel` functions? They're nicely tucked away in our `TodoUtil.js` or `TodoUtil/index.js` file:

<Highlighter code={`// TodoUtil.js
export const addTodo = name => cy
  .get('.new-todo')
  .type(\`\${name}{enter}\`)\n
export const getTopTodoFromList = () => cy
  .get('.todo-list')
  .eq(0)\n
export const getTodoLabel = todo => todo
  .find('label')
  .text()`} />

This is where we hide the imperative code. At some low level, we will always need to tell the computer **how** to do things. But if we abstract this code into library or utility functions with **concise, clear names**, then our actual code is as easy to read as plain English. That is a major benefit of working in a **declarative** style.
