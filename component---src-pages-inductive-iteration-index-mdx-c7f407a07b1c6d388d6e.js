(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{204:function(e,t,n){"use strict";n.r(t);n(14),n(15),n(8),n(22),n(16),n(0);var a=n(69),o=n(218),i=(n(217),n(222)),r=n(219),s={code:"// JUST DON'T DO THIS!\nconst nums = [1, 2, 3, 4, 5]\nconst len = nums.length\n\nlet sum = 0 // DON'T DO THIS!\n\nfor (let i = 0; i < len; i++) {\n  sum += nums[i] // Sum is a mutant!\n}\n\nconsole.log(`The sum is ${sum}`)",imports:"",requires:""},l={code:"const { adjust } = require('ramda')\n\nconst names = [\n  'Bob', 'Carole', 'Ted', 'Alice', 'Samson', 'Delilah'\n]\n\n// Vanilla JS: let's create our own function\nfunction vadjust (index, f, arr) {\n  return [\n    ...arr.slice(0, index),\n    f(arr[index]),\n    ...arr.slice(index + 1)\n  ]\n}\n\nconst vjsUpdatedNames = vadjust(1, () => 'Carol', names)\n\n// Ramda's adjust\nconst ramdaUpdatedNames = adjust(1, () => 'Carol', names)\n\nconsole.log('The updated names by vanilla JS:', vjsUpdatedNames)\nconsole.log('The updated names by Ramda\\'s adjust:', ramdaUpdatedNames)\nconsole.log('The original list is unchanged:', names)",imports:"",requires:""},c={code:"const { adjust, toUpper } = require('ramda')\n\nconst upcaseThirdElement = adjust(2, toUpper)\n\nconst names = [\n  'Bob', 'Carole', 'Ted', 'Alice', 'Samson', 'Delilah'\n]\n\nconst colours = [\n  'red', 'yellow', 'green', 'cyan', 'blue', 'magenta'\n]\n\nconsole.log('Uppercase the third name:', upcaseThirdElement(names))\nconsole.log('Uppercase the third colour:', upcaseThirdElement(colours))\nconsole.log('The original lists are unchanged:', names, colours)",imports:"",requires:""},u={code:"const { append } = require('ramda')\n\nconst nums = [1, 2, 3]\n\n// Vanilla\nconst vjsManual = [...nums, 4]\n\n// Our own append function\nconst vappend = (x, arr) => ([...arr, x])\n\nconst vjsAppend = vappend(4, nums)\n\n// Ramda\nconst ramdaAppend = append(4, nums)\n\nconsole.log('[...nums, 4]:', vjsManual)\nconsole.log('vappend(4, nums):', vjsAppend)\nconsole.log('append(4, nums):', ramdaAppend)\nconsole.log('nums is unchanged:', nums)",imports:"",requires:""},d={code:"const { filter } = require('ramda')\n\nconst names = [\n  'Bob', 'Carol', 'Ted', 'Alice', 'Samson', 'Delilah'\n]\n\n// Vanilla JS:\nconst vjsLongNames = names.filter(s => s.length > 4)\n\n// Ramda:\nconst ramdaLongNames = filter(s => s.length > 4, names)\n\nconsole.log('The longer names by Array.filter:', vjsLongNames)\nconsole.log('The longer names by Ramda\\'s filter:', ramdaLongNames)\nconsole.log('The original list is unchanged:', names)",imports:"",requires:""},p={code:"const { map, toUpper } = require('ramda')\n\nconst colours = ['red', 'green', 'blue']\n\n// Uppercase e's if length > 4\nconst longWordBigE = s => s.length > 4 ? s.replace(/e/g, 'E') : s\n\n// Vanilla JS\nconst vjsUppers = colours.map(longWordBigE)\n\n// The purely functional way with Ramda: pass the array\nconst ramdaUppers = map(longWordBigE, colours)\n\nconsole.log(`The uppercased colours by Array.map: [${vjsUppers}]`)\nconsole.log(`The uppercased colours by Ramda's map: [${ramdaUppers}]`)\nconsole.log(`Remember, the original array is unchanged: [${colours}]`)",imports:"",requires:""},m={code:"// Sadly, runkit does not support import yet\nconst { map } = require('ramda') // The old-fashioned way\n\nconst nums = [1, 2, 3, 4, 5]\n\n// Vanilla JS: map as a method on array\nconst vjsSquares = nums.map(x => x * x)\n\n// The purely functional way with Ramda: pass the array\nconst ramdaSquares = map(x => x * x, nums)\n\nconsole.log(`The squares by Array.map: ${JSON.stringify(vjsSquares)}`)\nconsole.log(`The squares by Ramda's map: ${JSON.stringify(ramdaSquares)}`)",imports:"",requires:""},b={code:"const { map, toUpper } = require('ramda')\n\nconst colours = ['red', 'green', 'blue']\n\n// Vanilla JS\nconst vjsUppers = colours.map(s => s.toUpperCase())\n\n// The purely functional way with Ramda: pass the array\nconst ramdaUppers = map(toUpper, colours)\n\nconsole.log(`The uppercased colours by Array.map: [${vjsUppers}]`)\nconsole.log(`The uppercased colours by Ramda's map: [${ramdaUppers}]`)",imports:"",requires:""},h={code:"const { prepend } = require('ramda')\n\nconst nums = [1, 2, 3]\n\n// Vanilla\nconst vjsManual = [0, ...nums]\n\n// Our own prepend function\nconst vprepend = (x, arr) => ([x, ...arr])\n\nconst vjsAppend = vprepend(0, nums)\n\n// Ramda\nconst ramdaAppend = prepend(0, nums)\n\nconsole.log('[0, ...nums]:', vjsManual)\nconsole.log('vprepend(0, nums):', vjsAppend)\nconsole.log('prepend(0, nums):', ramdaAppend)\nconsole.log('nums is unchanged:', nums)",imports:"",requires:""},g={code:"const { map, reduce } = require('ramda')\n\n// As with map, we take a function and an array to apply it to\nconst reduceMap = (f, arr) => reduce(\n  (acc, v) => ([...acc, f(v)]),  // Apply the function to each item in turn\n  [],                            // Start with an empty new array\n  arr                            // Loop through the original array\n)\n\nconst nums = [1, 2, 3, 4, 5]\n\nconst oldSquares = map(x => x * x, nums)\nconst squares = reduceMap(x => x * x, nums) // Works the same way\n\nconsole.log('The squares using map:', oldSquares)\nconsole.log('The squares using our reduceMap:', squares)\nconsole.log('And nums remains unchanged:', nums)",imports:"",requires:""},j={code:"const { keys, reduce, toUpper } = require('ramda')\n\n// Takes same three parameters as reduce, but last is an object\nconst reduceOverObject = (f, acc, obj) => reduce(\n  (a, key) => f(a, key, obj[key]), // function passed gets value as third parameter\n  acc,\n  keys(obj)\n)\n\nconst bob = {\n  name: 'Bob',\n  age: 'indeterminate',\n  iq: 180,\n  speaksFrench: true\n}\n\n// Now takes the value as a third parameter\nconst upcaseStrings = (acc, key, value) => ({\n  ...acc,                          // copy current accumulator\n  [key]: typeof value === 'string' // add this key-value pair\n    ? toUpper(value)               // uppercase if string\n    : value                        // otherwise, pass unchanged\n})\n\nconst upcased = reduceOverObject(upcaseStrings, {}, bob)\n\nconsole.log('Ramda result:', upcased)",imports:"",requires:""},f={code:"const { add, reduce } = require('ramda') // add(1, 2) returns 3\n\nconst nums = [1, 2, 3, 4, 5]\n\n// Vanilla JS\nconst vjsSum = nums.reduce(add, 0)\n\n// Ramda\nconst ramdaSum = reduce(add, 0, nums)\n\nconsole.log(`The Array.reduce sum is ${vjsSum}`)\nconsole.log(`The Ramda reduce sum is ${ramdaSum}`)",imports:"",requires:""},O={code:"const { keys, reduce, toUpper } = require('ramda')\n\nconst bob = {\n  name: 'Bob',\n  age: 'indeterminate',\n  iq: 180,\n  speaksFrench: true\n}\n\nconst upcaseStrings = (acc, key) => {\n  const value = bob[key]\n  \n  return {\n    ...acc,                          // copy current accumulator\n    [key]: typeof value === 'string' // add this key-value pair\n      ? toUpper(value)               // uppercase if string\n      : value                        // otherwise, pass unchanged\n  }\n}\n\nconst vjsUpcase = Object.keys(bob).reduce(upcaseStrings, {})\n\nconst ramdaUpcase = reduce(upcaseStrings, {}, keys(bob))\n\nconsole.log('Vanilla JS result:', vjsUpcase)\nconsole.log('Ramda result:', ramdaUpcase)",imports:"",requires:""},y={code:"function adjust (...args) {\n  // If not all arguments supplied...\n  if (args.length < 3) {\n    // Return a function that remembers the current arguments,\n    // takes more arguments, and calls adjust again with both\n    return (...newArgs) => adjust(...args, ...newArgs)\n  }\n  \n  // Once we have all three arguments, destructure them\n  const [index, f, arr] = args\n  \n  // If the index is out of bounds, return the array unchanged\n  if (index >= arr.length || index < -arr.length ) {\n    return arr\n  }\n  \n  return [\n    ...arr.slice(0, index),     // Get the elements before the index\n    f(...arr.slice(index)),     // Apply the function to the element at index\n    ...(\n      index === -1\n        ? []                    // Handle the special case of -1\n        : arr.slice(index + 1)) // Get the remaining elements, if any\n  ]\n}\n\nconst data = [0, 1, 2, 3, 4]\n\n// We can apply arguments in any increments\nconsole.log('adjust(2)(String)(data)', adjust(2)(String)(data))\nconsole.log('adjust(2, String)(data)', adjust(2, String)(data))\nconsole.log('adjust(2, String, data)', adjust(2, String, data))\nconsole.log('adjust(2)(String, data)', adjust(2)(String, data))\n\n// Calling with no arguments returns the function unchanged\nconsole.log('adjust()()(2)()(String)()()(data)', adjust()()(2)()(String)()()(data))\n\n// It works at different indexes\nconsole.log('adjust(3, String, data)', adjust(3, String, data))\nconsole.log('adjust(0, String, data)', adjust(0, String, data))\nconsole.log('adjust(4, String, data)', adjust(4, String, data))\n\n// It works with negative indexes\nconsole.log('adjust(-1, String, data)', adjust(-1, String, data))\nconsole.log('adjust(-4, String, data)', adjust(-4, String, data))\n\nconst adjustLast = adjust(-1)\nconst addTenToLast = adjustLast(x => x + 10)\n\nconsole.log('addTenToLast(data)', addTenToLast(data))",imports:"",requires:""},w={code:"// DON'T DO THIS EITHER\nconst nums = [1, 2, 3, 4, 5]\nconst len = nums.length\n\nlet sum = 0 // Ugh\n\nfor (num in nums) {\n  sum += num // Sum is still a mutant!\n}\n\nconsole.log(`The sum is ${sum}`) // Oh, look what happened here!",imports:"",requires:""},v={code:"// DON'T DO THIS EITHER\nconst nums = [1, 2, 3, 4, 5]\nconst len = nums.length\n\nlet sum = 0 // Ugh\n\nfor (i in nums) {\n  // console.log(typeof i) // uncomment this for a surprise\n  sum += nums[i] // i is the INDEX -- ick!\n}\n\nconsole.log(`The sum is ${sum}`) // Working, but definitely not intuitive",imports:"",requires:""},N={code:"function sum (nums = []) {\n  if (nums.length < 1) { return 0 }\n\n  const [head, ...tail] = nums\n\n  return head + sum(tail)\n}",imports:"",requires:""},C={code:"function mapSquares (nums = [], accumulator = []) {\n  // When nums is empty, return the accumulated squares\n  if (nums.length < 1) { return accumulator }\n\n  // Get the head and tail\n  const [head, ...tail] = nums\n  \n  // Append the square of the head and call again with the tail\n  return mapSquares(tail, [...accumulator, head * head])\n}\n\nconsole.log(`[] mapped to its squares is ${JSON.stringify(mapSquares([]))}`)\nconsole.log(`[5] mapped to its squares is ${JSON.stringify(mapSquares([5]))}`)\nconsole.log(`[1,2,3] mapped to its squares is ${JSON.stringify(mapSquares([1,2,3]))}`)",imports:"",requires:""},k={code:"function sum (nums = [], total = 0) {\n  console.log(`total is ${total}`)\n\n  if (nums.length < 1) {\n    console.log(`Returning the total of ${total}`)\n    return total\n  }\n\n  const [head, ...tail] = nums\n\n  console.log(`head is ${head} and tail is ${JSON.stringify(tail)}`)\n\n  console.log(`Calling sum(${JSON.stringify(tail)}, ${total + head})`, '')\n\n  return sum(tail, total + head)\n}\n\nconsole.log(`The sum of [1, 2, 3, 4, 5] is ${sum([1, 2, 3, 4, 5])}`)",imports:"",requires:""},x=n(228);n.d(t,"_frontmatter",function(){return T}),n.d(t,"default",function(){return E});var T={},S={_frontmatter:T},q=o.a;function E(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(a.b)(q,Object.assign({},S,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Loops are so last millennium!"),Object(a.b)("p",null,"If you've done much programming, then you've almost certainly used looping constructs. JavaScript offers numerous ways to loop in an \"imperative\" manner (meaning you tell the code to loop rather than just giving it a list of items and letting it decide how to loop):"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"for"),": repeat a code block a specified number of times"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"for/in"),": repeat a code block for each of the properties of an object"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"for/of"),': repeat  a code block for each values in an "iterable" object, such as an array'),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"while"),": repeat a block of code while a specified condition is true"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"do/while"),": same as while, but always applies the code block at least once")),Object(a.b)("p",null,"If you think these are easy to use, then you're fooling yourself. You've just been using them so long that you've forgotten how confusing they were the first time you saw them. Consider the ",Object(a.b)("inlineCode",{parentName:"p"},"for")," loop:"),Object(a.b)(i.a,Object.assign({},s,{theme:"dark",mdxType:"CodeBlock"})),Object(a.b)("p",null,"Easy, right?"),Object(a.b)("p",null,"Don't be absurd. There is ",Object(a.b)("em",{parentName:"p"},"nothing")," easy about this. Let's look at it a bit more carefully."),Object(a.b)("p",null,"First, what on Earth could this possibly mean?"),Object(a.b)(r.a,{code:"(let i = 0; i < len; i++)",showLineNumbers:!1,mdxType:"Highlighter"}),Object(a.b)("p",null,"OK, ",Object(a.b)("inlineCode",{parentName:"p"},"let i = 0;")," is obvious enough: we're setting a local, mutable variable to ",Object(a.b)("inlineCode",{parentName:"p"},"0"),". By why ",Object(a.b)("inlineCode",{parentName:"p"},"i"),"? Unless you've been ",Object(a.b)("em",{parentName:"p"},"taught")," how this works, it's not obvious that ",Object(a.b)("inlineCode",{parentName:"p"},"i")," is an ",Object(a.b)("em",{parentName:"p"},"index"),", or that we'll be incrementing it."),Object(a.b)("p",null,"So what is this ",Object(a.b)("inlineCode",{parentName:"p"},"i < len;"),"? A conditional, obviously, and we can see that ",Object(a.b)("inlineCode",{parentName:"p"},"len")," is ",Object(a.b)("inlineCode",{parentName:"p"},"5")," and ",Object(a.b)("inlineCode",{parentName:"p"},"i")," is ",Object(a.b)("inlineCode",{parentName:"p"},"0"),", so ",Object(a.b)("inlineCode",{parentName:"p"},"i < len")," is obviously ",Object(a.b)("inlineCode",{parentName:"p"},"true"),", but so what? What does that do?"),Object(a.b)("p",null,"And then there is this mystifying ",Object(a.b)("inlineCode",{parentName:"p"},"i++"),". Again, you have to be ",Object(a.b)("em",{parentName:"p"},"taught")," (and them memorise) that ",Object(a.b)("inlineCode",{parentName:"p"},"++")," is the ",Object(a.b)("strong",{parentName:"p"},"increment operator")," and that here it is applied to ",Object(a.b)("inlineCode",{parentName:"p"},"i")," in the ",Object(a.b)("strong",{parentName:"p"},"postfix")," position, which would normally mean that we would use the value ",Object(a.b)("em",{parentName:"p"},"first"),", and then increment it."),Object(a.b)("p",null,"But in truth in the ",Object(a.b)("inlineCode",{parentName:"p"},"for")," loop this increment is not applied until ",Object(a.b)("em",{parentName:"p"},"after")," the loop has run, and then is applied ",Object(a.b)("em",{parentName:"p"},"before")," the next iteration of the loop. So despite that nearly ",Object(a.b)("em",{parentName:"p"},"everyone")," who writes ",Object(a.b)("inlineCode",{parentName:"p"},"for")," loops uses ",Object(a.b)("inlineCode",{parentName:"p"},"i++"),", it really should be ",Object(a.b)("inlineCode",{parentName:"p"},"++i"),"—","and that will also work (try it)."),Object(a.b)("p",null,"Eventually, the new programmer figures out that ",Object(a.b)("inlineCode",{parentName:"p"},"i < len;")," is used to ",Object(a.b)("em",{parentName:"p"},"stop")," the loop. When this condition evaluates to ",Object(a.b)("inlineCode",{parentName:"p"},"false"),", the loop stops running. This condition is checked before ",Object(a.b)("em",{parentName:"p"},"every")," application of the code block, so if I write ",Object(a.b)("inlineCode",{parentName:"p"},"i > len;")," the loop never runs at all (try it)."),Object(a.b)("p",null,"But if you're familiar with this loop, then you'll know that the most common mistake is to write ",Object(a.b)("inlineCode",{parentName:"p"},"i <= len;"),", which causes the loop to run an extra iteration (try it). This throws no error, but results in ",Object(a.b)("inlineCode",{parentName:"p"},"sum")," being ",Object(a.b)("inlineCode",{parentName:"p"},"NaN"),". Not good."),Object(a.b)("p",null,"So awful is the ",Object(a.b)("inlineCode",{parentName:"p"},"for")," construct that later versions of JavaScript have introduced ",Object(a.b)("inlineCode",{parentName:"p"},"for/in")," and ",Object(a.b)("inlineCode",{parentName:"p"},"for/of"),". These simplify our loop, but again, you have to remember when to use ",Object(a.b)("inlineCode",{parentName:"p"},"in")," and when to use ",Object(a.b)("inlineCode",{parentName:"p"},"of"),", and this still ends up mutating a variable, though at least we don't have to worry about indexes:"),Object(a.b)(i.a,Object.assign({},w,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"Ha, ha. Yeah. You thought that ",Object(a.b)("inlineCode",{parentName:"p"},"for/in")," would pass you each item in the array one at a time? Seems obvious, but think again. It passes the ",Object(a.b)("em",{parentName:"p"},"index"),". So we're back to indexes! Let's try that again:"),Object(a.b)(i.a,Object.assign({},v,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"Wondering why we ended up with ",Object(a.b)("inlineCode",{parentName:"p"},"0012345")," in the broken version of ",Object(a.b)("inlineCode",{parentName:"p"},"for/in")," above? That's because for some difficult-to-grasp reason, the index is passed in as a ",Object(a.b)("strong",{parentName:"p"},"string"),", and the ",Object(a.b)("inlineCode",{parentName:"p"},"+=")," operator ",Object(a.b)("em",{parentName:"p"},"concatenates")," strings. WTF? WHY???"),Object(a.b)("p",null,"Here the TC-39 committee tried to make life easier for JavaScript coders and ended up making things just that much ",Object(a.b)("strong",{parentName:"p"},"less intuitive"),"."),Object(a.b)("p",null,"The above constructs work, and you can ",Object(a.b)("em",{parentName:"p"},"eventually")," get reasonably good at using them, but there is ",Object(a.b)("em",{parentName:"p"},"nothing intuitive")," about them and they are, in fact, one of the ",Object(a.b)("em",{parentName:"p"},"most difficult")," things for new programmers to learn."),Object(a.b)("p",null,"Surely, there is a better way!"),Object(a.b)("h3",{id:"recusrive-functions"},"Functions can call themselves! No, really..."),Object(a.b)("p",null,"One simple way to handle looping through a set of items, such as an array of numbers, is to process each number in turn. We can use a function call to do this, and rather than putting our function in a loop, we can just pass it the list, have it pop the first number off the list, process it, and then ",Object(a.b)("em",{parentName:"p"},"call itself again with the rest of the list"),"."),Object(a.b)("p",null,"And we can continue this until we run out of items to process. Then we will stop and return the fully processed list, whatever that looks like."),Object(a.b)("p",null,"For example, let's take our ",Object(a.b)("inlineCode",{parentName:"p"},"sum")," above. Adding a list of numbers together is the same as adding each number to the number after it and keeping a running total. If you think about it, that's precisely what our loop above does. It creates a running total in a ",Object(a.b)("inlineCode",{parentName:"p"},"sum")," variable and initialises it to ",Object(a.b)("inlineCode",{parentName:"p"},"0"),", then adds the numbers in the list to it sequentially until it exhausts the list. What's left is our final total."),Object(a.b)("p",null,"We can do the same thing by creating a function that takes our list and our running total (defaulting to ",Object(a.b)("inlineCode",{parentName:"p"},"0"),"), and calls itself on the first item, adding it to the running total, and then calling itself again on the rest of the list and passing the current subtotal:"),Object(a.b)(i.a,Object.assign({},x.a,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"That works. Of course, we could have written the function more simply this way, but doing so might create a problem:"),Object(a.b)(r.a,{code:N.code,mdxType:"Highlighter"}),Object(a.b)("p",null,"So why not do it that way?"),Object(a.b)("p",null,"Well, a minor benefit of having the running total as a parameter to the function is that we can set it to something other than zero. For example, we could add a list of numbers to ",Object(a.b)("inlineCode",{parentName:"p"},"100")," instead of zero","—",Object(a.b)("inlineCode",{parentName:"p"},"sum([1, 4, 9, 16], 100)"),"—","returning ",Object(a.b)("inlineCode",{parentName:"p"},"130")," instead of ",Object(a.b)("inlineCode",{parentName:"p"},"30"),"."),Object(a.b)("p",null,"But a more important reason is found in line ","#","6: ",Object(a.b)("inlineCode",{parentName:"p"},"return head + sum(tail)"),". By choosing to do it this way, we have to push our first function call onto the stack (in memory) and ",Object(a.b)("em",{parentName:"p"},"wait for the second call to return")," before we can return from the first. Then we have to push the second call onto the stack and wait for the third, etc."),Object(a.b)("p",null,"If the list is 1000 items long, then we have to hold 999 calls on the stack waiting for that last call to return. That takes a lot of memory. But we can't do the addition","—",Object(a.b)("inlineCode",{parentName:"p"},"head + sum(tail)"),"—","until we know what ",Object(a.b)("inlineCode",{parentName:"p"},"sum(tail)")," is, right? So we're stuck."),Object(a.b)("p",null,"But if we do it like this:"),Object(a.b)(r.a,{code:"return sum(tail, total + head)",showLineNumbers:!1,mdxType:"Highlighter"}),Object(a.b)("p",null,"Then we ",Object(a.b)("em",{parentName:"p"},"know")," what ",Object(a.b)("inlineCode",{parentName:"p"},"tail")," is and we ",Object(a.b)("em",{parentName:"p"},"know")," what ",Object(a.b)("inlineCode",{parentName:"p"},"total + head")," is ",Object(a.b)("em",{parentName:"p"},"at the time of the function call"),". So instead of pushing our function onto the stack and waiting for the second iteration to return, we can simply ",Object(a.b)("strong",{parentName:"p"},"replace")," the first function call with the second, right?"),Object(a.b)("p",null,"Essentially, writing our function-that-calls-itself in this manner makes it work ",Object(a.b)("em",{parentName:"p"},"exactly like a loop"),". So it's as fast and uses as little memory, effectively. Now we get the benefits of the speed and efficiency of a loop without all the unintuitive looping constructs: the best of both worlds."),Object(a.b)("p",null,"Looked at another way, the second example above runs ",Object(a.b)("em",{parentName:"p"},"nested"),":"),Object(a.b)(r.a,{code:"sum([1, 2, 3, 4, 5]) === 1 + (\n  2 + (\n    3 + (\n      4 + (\n        5 + (\n          0\n        )\n      )\n    )\n  )\n)",mdxType:"Highlighter"}),Object(a.b)("p",null,"Which means it actually adds the list from last to first: ",Object(a.b)("inlineCode",{parentName:"p"},"0 + 5 + 4 + 3 + 2 + 1"),"."),Object(a.b)("p",null,"The first example above just makes successive calls to the same function:"),Object(a.b)(r.a,{code:"sum([1, 2, 3, 4, 5]) // replaced by\nsum([2, 3, 4, 5], 1) // replaced by\nsum([3, 4, 5], 3)    // replaced by\nsum([4, 5], 6)       // replaced by\nsum([5], 10)         // returns 15",mdxType:"Highlighter"}),Object(a.b)("p",null,"So this version adds in the order you'd expect: ",Object(a.b)("inlineCode",{parentName:"p"},"0 + 1 + 2 + 3 + 4 + 5"),"."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Each of the three lines of our function block has a specific purpose"),"."),Object(a.b)("p",null,"For a function calling itself to work, we must observe two rules:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"We must have a ",Object(a.b)("strong",{parentName:"li"},"base case")," where the function returns something ",Object(a.b)("em",{parentName:"li"},"without")," calling itself."),Object(a.b)("li",{parentName:"ol"},"Each time we call the function from within the function we must call it with ",Object(a.b)("em",{parentName:"li"},"different")," arguments, ",Object(a.b)("em",{parentName:"li"},"and the arguments must approach the base case!"))),Object(a.b)("p",null,"Let's look at the lines one at a time:"),Object(a.b)(r.a,{code:"if (nums.length < 1) { return total }",startingLineNumber:2,mdxType:"Highlighter"}),Object(a.b)("p",null,'This is our "base case". It tells our function when to ',Object(a.b)("strong",{parentName:"p"},"stop")," calling itself. When there is nothing left in the array that we're passing to our function","—","i.e., the argument is the empty list","—","then we just return our running total. That stops the loop. It's essentially a guard statement."),Object(a.b)(r.a,{code:"const [head, ...tail] = nums",startingLineNumber:4,mdxType:"Highlighter"}),Object(a.b)("p",null,"We are always going to operate on one element of the array at a time, so we'll need to pop the head off the array. When we next call the function, it will be on the remaining elements","—","the ",Object(a.b)("strong",{parentName:"p"},"tail"),"—","so we need to hang on to those as well."),Object(a.b)("p",null,'Recall that arrays are passed by "reference", which means they are not copied in but merely pointed to. So we\'ll want to copy the tail and use the copy rather than mutating the original list. Destructuring and the ',Object(a.b)("inlineCode",{parentName:"p"},"...")," (rest) syntax achieves that for us."),Object(a.b)("p",null,"When we do:"),Object(a.b)(r.a,{code:"const [head, ...tail] = [1, 2, 3, 4, 5]",showLineNumbers:!1,mdxType:"Highlighter"}),Object(a.b)("p",null,"Then:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"variable ",Object(a.b)("inlineCode",{parentName:"li"},"head")," has value ",Object(a.b)("inlineCode",{parentName:"li"},"1")),Object(a.b)("li",{parentName:"ul"},"variable ",Object(a.b)("inlineCode",{parentName:"li"},"tail")," has value ",Object(a.b)("inlineCode",{parentName:"li"},"[2, 3, 4, 5]"),".")),Object(a.b)("p",null,"Finally, we do the work in our third line of code:"),Object(a.b)(r.a,{code:"return sum(tail, total + head)",startingLineNumber:6,mdxType:"Highlighter"}),Object(a.b)("p",null,"First time through, our ",Object(a.b)("inlineCode",{parentName:"p"},"total")," defaulted to ",Object(a.b)("inlineCode",{parentName:"p"},"0"),", so given the ",Object(a.b)("inlineCode",{parentName:"p"},"head")," and ",Object(a.b)("inlineCode",{parentName:"p"},"tail")," above, this becomes:"),Object(a.b)(r.a,{code:"return sum([2, 3, 4, 5], 0 + 1)",showLineNumbers:!1,mdxType:"Highlighter"}),Object(a.b)("p",null,"Watch it in action:"),Object(a.b)(i.a,Object.assign({},k,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"As you can see, the ",Object(a.b)("inlineCode",{parentName:"p"},"total")," accumulates the value of our running total. But we could accumulate anything, right?"),Object(a.b)("p",null,"Consider an example where we have an array of numbers and we want to convert it to an array of the ",Object(a.b)("em",{parentName:"p"},"squares")," of those numbers. In other words, we want to loop through the array squaring each element and returning a ",Object(a.b)("em",{parentName:"p"},"new")," array of the squares. Easy!"),Object(a.b)(i.a,Object.assign({},C,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"Passing an accumulator makes it possible to do almost ",Object(a.b)("em",{parentName:"p"},"anything")," a loop can do by simply writing a function that calls itself."),Object(a.b)("p",null,"Writing functions that call themselves is easy and fun, but functional JavaScript is all about ",Object(a.b)("strong",{parentName:"p"},"reusability"),". It doesn't take writing too many functions like the ones above to start to see certain patterns emerging."),Object(a.b)("p",null,"When we wrote our ",Object(a.b)("inlineCode",{parentName:"p"},"sum")," function, we took a list of items and reduced it down to a single item. We can write a function called ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," that takes a list of items and reduces it to a single output. We just need three things:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"The code block that will be executed each time the function runs"),Object(a.b)("li",{parentName:"ol"},"The starting value of our accumulator (",Object(a.b)("inlineCode",{parentName:"li"},"0")," and ",Object(a.b)("inlineCode",{parentName:"li"},"[]")," respectively above)"),Object(a.b)("li",{parentName:"ol"},"The list on which we'll operate (",Object(a.b)("inlineCode",{parentName:"li"},"[1, 2, 3, 4, 5]")," above)")),Object(a.b)("p",null,"But we want our ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," function to be generic, so we'll want to pass it the code block. How do we pass code blocks around in functional JavaScript? ",Object(a.b)("strong",{parentName:"p"},"Functions"),", of course. So our ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," function will take:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"A ",Object(a.b)("strong",{parentName:"li"},"function")," to be applied to the accumulator and each item of the list in turn"),Object(a.b)("li",{parentName:"ol"},"The starting accumulator"),Object(a.b)("li",{parentName:"ol"},"The list of values")),Object(a.b)("p",null,"And we can see that the function we provide as our first argument must:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Take the accumulator (running total) as an argument"),Object(a.b)("li",{parentName:"ol"},"Take the head of the list as an argument"),Object(a.b)("li",{parentName:"ol"},"Return a ",Object(a.b)("em",{parentName:"li"},"new")," accumulator value, which will be used on the next call")),Object(a.b)("p",null,"When we ",Object(a.b)("inlineCode",{parentName:"p"},"map")," our list to the squares of the numbers, things get even simpler. We know we're just mapping from one array to another of equal size, right? So our starting accumulator is always ",Object(a.b)("inlineCode",{parentName:"p"},"[]"),", so we don't need to pass it to our function. We can create a ",Object(a.b)("inlineCode",{parentName:"p"},"map")," function that:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Takes a function to apply to each item in a list"),Object(a.b)("li",{parentName:"ol"},"Takes a list of items to apply it to"),Object(a.b)("li",{parentName:"ol"},"Returns a ",Object(a.b)("em",{parentName:"li"},"new")," list of the results from passing the originals list's items through the function supplied")),Object(a.b)("p",null,"Modern JavaScript provides functions such as ",Object(a.b)("inlineCode",{parentName:"p"},"map")," and ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," (and many more) already implemented for you. You just need to supply the right arguments."),Object(a.b)("p",null,"The built-in versions work in a very OO way: You call the ",Object(a.b)("inlineCode",{parentName:"p"},"map")," ",Object(a.b)("em",{parentName:"p"},"method")," on the array you want to map, pass it the function you want to apply to each item in turn, and it returns a ",Object(a.b)("em",{parentName:"p"},"new")," array of the results."),Object(a.b)("p",null,"Similarly, you call the ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," method on the array you want to reduce in some way, pass it the function that takes the accumulator and each item in turn and returns a new accumulator value, and pass it the starting accumulator. It returns the accumulator, whatever that is."),Object(a.b)("p",null,"There is an even better way to do this functionally by pulling the methods out into their own functions, and passing the lists they operate on as an argument, rather than as the caller of a method. For this purpose, there are numerous libraries out there, the most popular of which is ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/lodash/lodash/wiki/FP-Guide"}),"lodash")," (but only use the ",Object(a.b)("inlineCode",{parentName:"p"},"lodash/fp")," module!)."),Object(a.b)("p",null,"The ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://ramdajs.com/"}),"ramda")," library is much better, having been built (mostly) correctly from the getgo. The best, however, is ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://sanctuary.js.org/"}),"sanctuary"),", which is ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://sanctuary.js.org/#overview"}),"scrupulously correct"),", but this also makes it difficult to use in production. There is no slack at all. You must be ",Object(a.b)("em",{parentName:"p"},"meticulous"),"."),Object(a.b)("p",null,"For most cases, ",Object(a.b)("inlineCode",{parentName:"p"},"ramda")," is your best bet unless you are already committed to something else. Below we examine the most common functions/methods available and show how they can be used both in vanilla JavaScript and in ",Object(a.b)("inlineCode",{parentName:"p"},"ramda"),"."),Object(a.b)("p",null,'(Note: While there is a Node framework called "VanillaJS" with no apparent sense of irony, what we mean here by vanilla JavaScript is JavaScript used ',Object(a.b)("em",{parentName:"p"},"without")," adding libraries or frameworks","—","using only the built-in functionality.)"),Object(a.b)("p",null,"(P.S. the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://ramdajs.com/repl/"}),"Ramda REPL")," is awesome.)"),Object(a.b)("h3",{id:"map"},"Use ",Object(a.b)("code",null,"map")," to modify each value in a list"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"map")," method (or function) does exactly what our ",Object(a.b)("inlineCode",{parentName:"p"},"map")," method above does, except abstractly. In other words, to get it to ",Object(a.b)("em",{parentName:"p"},"square")," each  of the numbers in our array, we need to pass it a squaring function: ",Object(a.b)("inlineCode",{parentName:"p"},"x => x * x")," will work:"),Object(a.b)(i.a,Object.assign({},m,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"They work the same, so why use the latter? We'll see advantages when we get to pipelining functions below. If you're working on a small project and you can do it entirely in vanilla JS without importing a library such as Ramda, then probably you should use vanilla JS. But on most larger projects, you're going to need a library such as Ramda for many things, so you might as well use Ramda functions over the built in ones."),Object(a.b)("p",null,"But more on that below. Let's take another example of ",Object(a.b)("inlineCode",{parentName:"p"},"map")," before we move on:"),Object(a.b)(i.a,Object.assign({},b,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"OK, one more:"),Object(a.b)(i.a,Object.assign({},p,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"So we can use conditionals or anything we like really, modifying some, all, or none."),Object(a.b)("h3",{id:"reduce"},"Use ",Object(a.b)("code",null,"reduce")," to combine elements in a list"),Object(a.b)("p",null,"We've already talked about ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," above. It takes a function, a starting accumulator, and the list to process. It returns the final accumulator. Above we used ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," first to add a list of numbers. Let's do it again using the ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," method and Ramda's ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," function:"),Object(a.b)(i.a,Object.assign({},f,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"We'll see ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," again and again in the examples below. You can make any of these other functions from ",Object(a.b)("inlineCode",{parentName:"p"},"reduce"),"."),Object(a.b)("h3",{id:"reduce-again"},"More fun with ",Object(a.b)("code",null,"reduce")),Object(a.b)("p",null,"Suppose we want to loop through an object and uppercase every string value. Can we do that with ",Object(a.b)("inlineCode",{parentName:"p"},"reduce"),"? Easy peasy:"),Object(a.b)(i.a,Object.assign({},O,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"The above example isn't the greatest. We reach outside the ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," function to access our ",Object(a.b)("inlineCode",{parentName:"p"},"bob")," object. We should really wrap the function and make a version that takes an object:"),Object(a.b)(i.a,Object.assign({},j,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"Now we're beginning to see the advantage of Ramda. Our new ",Object(a.b)("inlineCode",{parentName:"p"},"reduceOverObject")," function takes a function and passes it ",Object(a.b)("em",{parentName:"p"},"three")," arguments: the current accumulator, the current key, and the current value. And we pass it the object rather than just the array of keys."),Object(a.b)("p",null,"Sweet. Everything is neatly contained in my ",Object(a.b)("inlineCode",{parentName:"p"},"reduceOverObject")," function. Consider how clean and readable this line is:"),Object(a.b)(r.a,{code:"const upcased = reduceOverObject(upcaseStrings, {}, bob)",startingLineNumber:25,mdxType:"Highlighter"}),Object(a.b)("p",null,"Can we duplicate the ",Object(a.b)("inlineCode",{parentName:"p"},"map")," function with ",Object(a.b)("inlineCode",{parentName:"p"},"reduce"),"? Easy!"),Object(a.b)(i.a,Object.assign({},g,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"No need to write this function, of course! Just use ",Object(a.b)("inlineCode",{parentName:"p"},"map"),". But as you'll see here, ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," is the mother of all these functions. We can recreate all of them with ",Object(a.b)("inlineCode",{parentName:"p"},"reduce"),", and we can build even more powerful functions on top of ",Object(a.b)("inlineCode",{parentName:"p"},"reduce"),". And ",Object(a.b)("inlineCode",{parentName:"p"},"reduce")," is easily created itself by writing a function that calls itself."),Object(a.b)("p",null,"Functional code, especially with reuse, is ",Object(a.b)("em",{parentName:"p"},"simpler")," than the OO equivalent. That means fewer lines, drier code, more reusability, and more power. Free your methods! Use functions instead, and treat Objects as types to be passed around, rather than the output of ",Object(a.b)("inlineCode",{parentName:"p"},"new <ClassName>()"),"."),Object(a.b)("h3",{id:"filter"},"Use ",Object(a.b)("code",null,"filter")," to choose particular values from a list"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"filter")," method or function takes a function that returns a Boolean value and a list of items. It applies the function to each item in the list in turn. If the value returned is ",Object(a.b)("inlineCode",{parentName:"p"},"true"),", then that item is included in the output list. If it is ",Object(a.b)("inlineCode",{parentName:"p"},"false"),", then it isn't included. Remember, the output is a copy."),Object(a.b)("p",null,"Suppose we had a list of names and we wanted to find all the names at least 5 letters long. We could do that easily with the ",Object(a.b)("inlineCode",{parentName:"p"},"filter")," method:"),Object(a.b)(i.a,Object.assign({},d,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"Who needs loops? Not us."),Object(a.b)("h3",{id:"adjust"},"Use ",Object(a.b)("code",null,"adjust")," to update a single value in a list"),Object(a.b)("p",null,"What if we want to update an element at a specified index in an array. The mutable way would be simple: ",Object(a.b)("inlineCode",{parentName:"p"},"names[1] = 'Carole'"),"."),Object(a.b)("p",null,"But that mutates our original list. What we want is a new copy of the list with just that element updated. Ramda provides an ",Object(a.b)("inlineCode",{parentName:"p"},"adjust")," function to do just this, but we could also write our own version in vanilla JS:"),Object(a.b)(i.a,Object.assign({},l,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"Now you're probably wondering why we might add the Ramda dependency with its load time if we can write our own functions so easily."),Object(a.b)("p",null,"Well, it depends on what we need. If our needs are as simple as above, then write our own is probably the way to go. (But be advised that we are then responsible for testing and maintaining our utility function as well.)"),Object(a.b)("p",null,"But the Ramda ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://ramdajs.com/docs/#adjust"}),"adjust")," function can do much more than our version. For one thing, we can apply the arguments ",Object(a.b)("em",{parentName:"p"},"one a time"),", and with each, get back a function that remembers the arguments already supplied and takes the remaining parameters:"),Object(a.b)(i.a,Object.assign({},c,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"Ramda's ",Object(a.b)("inlineCode",{parentName:"p"},"adjust")," can also handle negative indexes (it works back from the end of the list). Our ",Object(a.b)("inlineCode",{parentName:"p"},"vadjust")," fails on negative indexes. And if we pass an index that's out of range, then Ramda's ",Object(a.b)("inlineCode",{parentName:"p"},"adjust")," returns our list unchanged so we can continue processing. Again, our version fails. We could fix our version:"),Object(a.b)(i.a,Object.assign({},y,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"But now it's on us to test it and keep it current. So much easier to use a library such as Ramda or Lodash/FP."),Object(a.b)("h3",{id:"append"},"Use ",Object(a.b)("code",null,"append"),", ",Object(a.b)("code",null,"insert"),", or ",Object(a.b)("code",null,"prepend")," to add an item to a list"),Object(a.b)("p",null,"These functions do exactly what you'd expect. Should we do it by hand, or use a library. For ",Object(a.b)("inlineCode",{parentName:"p"},"append")," and ",Object(a.b)("inlineCode",{parentName:"p"},"prepend"),", at least, vanilla JS is probably enough (unless we're pipelining","—",'"composing"',"—","functions)."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"append")," is the easiest:"),Object(a.b)(i.a,Object.assign({},u,{mdxType:"CodeBlock"})),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"prepend")," is also very easy:"),Object(a.b)(i.a,Object.assign({},h,{mdxType:"CodeBlock"})),Object(a.b)("h3",{id:"concat"},"Use ",Object(a.b)("code",null,"concat")," or ",Object(a.b)("code",null,"zip")," to combine two lists"),Object(a.b)("p",null,"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."),Object(a.b)("h3",{id:"times"},"Use ",Object(a.b)("code",null,"times")," to create a new list"),Object(a.b)("p",null,"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."),Object(a.b)("h3",{id:"head"},"Use ",Object(a.b)("code",null,"head")," or destructuring to get the first item in a list"),Object(a.b)("p",null,"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."),Object(a.b)("h3",{id:"tail"},"Use ",Object(a.b)("code",null,"tail")," or destructuring to get the list minus the first element"),Object(a.b)("p",null,"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."),Object(a.b)("h3",{id:"all"},"Use ",Object(a.b)("code",null,"all"),", ",Object(a.b)("code",null,"any"),", or ",Object(a.b)("code",null,"none")," to test a list"),Object(a.b)("p",null,"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."),Object(a.b)("h3",{id:"flatten"},"Use ",Object(a.b)("code",null,"flatten")," to flatten nested lists into a single list"),Object(a.b)("p",null,"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."),Object(a.b)("h3",{id:"avoid-foreach"},"Avoid ",Object(a.b)("code",null,"forEach"),"! Avoid ",Object(a.b)("code",null,"forEach"),"! Avoid ",Object(a.b)("code",null,"forEach"),"!"),Object(a.b)("p",null,"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."),Object(a.b)("small",null,"Errors, bugs, suggestions, questions? Contact ",Object(a.b)("a",{href:"mailto:charles_munat@bnz.co.nz"},"Charles Munat")),".")}E.isMDXComponent=!0},210:function(e,t,n){"use strict";var a=n(0),o=n.n(a),i=n(68),r=n.n(i);n.d(t,"a",function(){return r.a});n(211),n(9).default.enqueue,o.a.createContext({})},211:function(e,t,n){var a;e.exports=(a=n(213))&&a.default||a},212:function(e){e.exports={data:{site:{siteMetadata:{title:"How to FP"}}}}},213:function(e,t,n){"use strict";n.r(t);n(52),n(17),n(14),n(15),n(8),n(22);var a=n(0),o=n.n(a),i=n(96);function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}t.default=function(e){var t=e.location,n=e.pageResources;return n?o.a.createElement(i.a,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(n,!0).forEach(function(t){s(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(n).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}({location:t,pageResources:n},n.json)):null}},214:function(e,t,n){"use strict";var a=n(215),o=n(0),i=n.n(o),r=n(221),s=n.n(r);function l(e){var t=e.lang,n=e.title,o=a.data.site;return i.a.createElement(s.a,{htmlAttributes:{lang:t},title:n?n+" | "+o.siteMetadata.title:o.siteMetadata.title},i.a.createElement("script",{src:"https://embed.runkit.com","data-element-id":"runkit"}))}l.defaultProps={lang:"en",meta:[],description:""},t.a=l},215:function(e){e.exports={data:{site:{siteMetadata:{title:"How to FP",description:"Functional JavaScript for the OO programmer.",author:"@chasm"}}}}},216:function(e,t,n){"use strict";var a=n(212),o=(n(220),n(0)),i=n.n(o),r=(n(16),n(41),n(210)),s=n(23);function l(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(r.a,{to:"/inductive",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"Bottom-up"),i.a.createElement(r.a,{to:"/deductive",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"Top-down"),i.a.createElement(r.a,{to:"/patterns-antipatterns",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"Patterns"))}function c(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(r.a,{to:"/inductive/reusability",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"Reusability"),i.a.createElement(r.a,{to:"/inductive/immutability",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"Variables"),i.a.createElement(r.a,{to:"/inductive/iteration",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"Looping"),i.a.createElement(r.a,{to:"/inductive/composition",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"Pipelines"))}function u(){return i.a.createElement(i.a.Fragment,null,i.a.createElement(r.a,{to:"/deductive/pure-functions/",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"Pure functions"),i.a.createElement(r.a,{to:"/deductive/more-fp-concepts",style:{color:"white",textDecoration:"none",textTransform:"lowercase",display:"inline-block",padding:"0 0.5rem"}},"More FP concepts"))}function d(e){switch(e.location.pathname.split("/")[1]){case"inductive":return i.a.createElement(c,null);case"deductive":return i.a.createElement(u,null);default:return i.a.createElement(l,null)}}var p=function(e){var t=e.siteTitle,n=e.location,a=function(e){switch(e.pathname.split("/")[1]){case"inductive":return"ForestGreen";case"deductive":return"MediumBlue";case"patterns-antipatterns":return"Maroon";default:return"RebeccaPurple"}}(n);return i.a.createElement("header",{style:{background:a,marginBottom:"1.45rem"}},i.a.createElement("div",{style:{display:"flex",alignItems:"center",margin:"0 auto",maxWidth:960,padding:"1.45rem 1.0875rem"}},i.a.createElement("h1",{style:{margin:0,display:"inline-block",flexGrow:1}},i.a.createElement(r.a,{to:"/",style:{color:"white",textDecoration:"none"}},t)),i.a.createElement("div",{style:{flexShrink:1}},i.a.createElement(d,{location:n}))))};function m(e){return i.a.createElement(s.Location,null,function(t){return i.a.createElement(p,Object.assign({},t,e))})}p.defaultProps={siteTitle:""};t.a=function(e){var t=e.children,n=a.data;return i.a.createElement(i.a.Fragment,null,i.a.createElement(m,{siteTitle:n.site.siteMetadata.title}),i.a.createElement("div",{style:{margin:"0 auto",maxWidth:960,padding:"0 1.0875rem 1.45rem",paddingTop:0}},i.a.createElement("main",null,t)))}},217:function(e,t,n){"use strict";n.d(t,"a",function(){return c});n(14),n(15),n(8),n(22),n(16);var a=n(210),o=n(0),i=n.n(o),r=n(23);var s=/#|\?/g,l=function(e){return function(){return Object(r.navigate)(e)}};function c(e){var t=e.children,n=e.to,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["children","to"]);return s.test(n)?i.a.createElement("a",Object.assign({onClick:l(n)},o),t):i.a.createElement(a.a,Object.assign({to:n},o),t)}},218:function(e,t,n){"use strict";var a=n(0),o=n.n(a),i=n(210);function r(){return o.a.createElement("span",{className:"separator"},"»")}function s(e){var t=e.title,n=e.trail;return void 0===n?null:o.a.createElement("p",null,function(e,t){return void 0===t&&(t=[]),o.a.createElement(o.a.Fragment,null,t.map(function(e){var t=e.href,n=e.label;return o.a.createElement(a.Fragment,{key:t},o.a.createElement(i.a,{to:t},n),o.a.createElement(r,null))}),e)}(t,n))}var l=n(216),c=n(214);t.a=function(e){var t=e.children,n=e.pageContext.frontmatter,a=n.title,i=n.trail;return o.a.createElement(l.a,null,o.a.createElement(c.a,{title:a}),o.a.createElement(s,{title:a,trail:i}),o.a.createElement("article",null,t))}},219:function(e,t,n){"use strict";n.d(t,"a",function(){return l});var a=n(0),o=n.n(a),i=n(430),r=n(428),s=n(429);function l(e){var t=e.code,n=void 0===t?"":t,a=e.language,l=void 0===a?"javascript":a,c=e.showLineNumbers,u=void 0===c||c,d=e.startingLineNumber,p=void 0===d?1:d,m=e.theme,b=void 0===m?"light":m;return o.a.createElement(i.a,{language:l,style:"light"===b?r.a:s.a,showLineNumbers:u,startingLineNumber:p},n)}},222:function(e,t,n){"use strict";n.d(t,"a",function(){return l});var a=n(0),o=n.n(a),i=n(223),r=n.n(i),s=n(219);function l(e){var t=e.code,n=void 0===t?"":t,i=e.imports,l=void 0===i?"":i,c=e.requires,u=void 0===c?"":c,d=e.theme,p=void 0===d?"light":d,m=Object(a.useState)(!1),b=m[0],h=m[1];return Object(a.useEffect)(function(){var e=setInterval(function(){h(Boolean(window)&&Boolean(window.RunKit))},1e3);return b&&clearInterval(e),function(){return clearInterval(e)}},[]),b?o.a.createElement("div",{className:"code-block"},o.a.createElement(r.a,{source:""+u+n,nodeVersion:"12",theme:"solarized-"+p})):o.a.createElement(s.a,{code:""+l+n,theme:p})}},228:function(e,t,n){"use strict";t.a={code:"function sum (nums = [], total = 0) {\n  if (nums.length < 1) { return total } // If nums is empty, return the total\n\n  const [head, ...tail] = nums // Get the head (first number) and the tail (remaining numbers)\n\n  return sum(tail, total + head) // The function calls itself!\n}\n\nconsole.log(`The sum of [] is ${sum([])}`)\nconsole.log(`The sum of [5] is ${sum([5])}`)\nconsole.log(`The sum of [1, 2, 3] is ${sum([1, 2, 3])}`)",imports:"",requires:""}}}]);
//# sourceMappingURL=component---src-pages-inductive-iteration-index-mdx-c7f407a07b1c6d388d6e.js.map