---
path: "/test"
title: "How to FP"
---

## Rule #1

**As often as possible, functions should take _at least_ one argument and return _exactly one_ result.**

```javascript
// square(3) returns 9
function square (x) {
  return x * x
}

// add(2, 3) returns 5
function add (x, y) {
  return x + y
}
```

### Corollary to Rule #1

**As often as possible, the output of a function should depend _only_ on its inputs: the same inputs should _always_ return the same output.**

This allows us to reason about our code by simplifying it using substitution. If `square(3)` _always_ returns `9`, then everywhere I see `square(3)` in my code, I can replace it with `9`.

This is another way of saying that a function should only change what is _inside_ the function.

Primitive values such as numbers, booleans, and strings are passed in "by value", which means that a copy is made inside the function and you are operating on that copy. Consider this:

```javascript
function makeShade (baseColour) {
  return 'dark ' + baseColour
}

const colour = 'red'

makeShade(colour) // returns 'dark red'

// colour is still 'red'
```

In the above example, when `makeShade` is called with the value of `colour`, it makes a _copy_ of its value ('red') and puts it in a local variable called `baseColour`. We then prepend 'dark ' to it and return the new value. So our original variable, `colour`, remains unchanged.

In contrast, when we pass in a complex type such as an array or an object, it is passed in "by reference", which means that instead of making a copy of the value, our local variable points to the outer variable's value. So if we change that local variable in our function, it changes outside the function as well.

**We want to avoid this as much as possible.** Life is much easier when variables, once set, never change. Instead, make copies.

In the example below, we make a copy of the array that was passed in using the `...` "spread" operator. This takes the items in the passed-in array and "spreads" them out into a new array. Now we can append our new value by including it at the end of the new array:

```javascript
function append (value, list) {
  return [...list, value]
}

const arr = [1, 2, 3]

append(4, arr) // returns [1, 2, 3, 4]

// arr is still [1, 2, 3]
```

We can `prepend` just as easily:

```javascript
function prepend (value, list) {
  return [value, ...list]
}

const arr = [2, 3, 4]

prepend(1, arr) // returns [1, 2, 3, 4]
```

This works with objects as well:

```javascript
function setColour (colour, options) {
  return {
    ...options,
    colour // shorthand for `colour: colour`
  }
}

const myOptions = {
  name: 'Bob',
  age: 27,
  colour: 'blue'
}

setColour('green', myOptions) // returns { name: 'Bob', age: 27, colour: 'green' }

// myOptions.colour is still 'blue
```

## Rule #2

**Assign the value of a variable when it is declared (immediately), then _never change it_. Instead, create a new variable.**

First, this means that we will always assign a variable when we declare it, and once we've assigned it, we will never re-assign it. In JavaScript, `let` is used for variables that we may want to re-assign (just forget all about `var`). If a variable will not be re-assigned, we can use `const` instead. Therefore, as much as possible, **you should always use `const` to declare variables in JavaScript**. As `const` cannot be re-assigned, you will be forced to assign it as you declare it.

If you "must" use `let`, examine carefully _why_ you are using it. This should be a very, very rare occurrence, as in, um, _never_. Virtually always there is a _better_ approach using `const`. Get used to `const`!

Note, however, that using `const` is not enough to ensure that a variable is never changed! It is true that if you use `const` with a a "primitive" type such as a number, then it is "immutable" (can't be changed):

```javascript
const x = 3

x = 5 // throws an "x is read-only" error
```

But while `const` prevents the variable from being re-assigned, when the variable is a complex type such as an array or object, it is still possible to reach into that value and change it internally.

**Don't.**

When you need to _change_ a variable, create a new variable instead.

But doesn't this making looping difficult? Yes, it does! So...

## Rule #3

**Avoid loops! Use functions instead.**

JavaScript has a host of built-in methods that allow you to avoid loops in most (if not all) instances. Even better, there are libraries such as `ramda` and `lodash/fp` (never use the non-fp lodash as it is broken) that provide truly-functional versions of these methods.

What are these amazing functions/methods? Among the most used are `map`, `filter`, `find`, `reduce`, `join`, and `sort`. Let's look at some examples. We've included the way to do each of these using the built-in methods as well (so-called "Vanilla JS"), but the pure functional way is better in most circumstances. We'll explain why later in this tutorial. Patience, please.

### map

The `map` function is used to apply some kind of transformation to each item in a list, and to return a _new_ list of the transformed items. Because `map` transforms each item in the list successively, it always returns a new list (array) _of the same length_. Remember that.

```javascript
import { map, toUpper } from 'ramda'

toUpper('make me big') // returns 'MAKE ME BIG'

const words = ['these', 'aRe', 'Some', 'strINGS']

// Convert all strings to uppercase
map(toUpper, words) // returns ['THESE', 'ARE', 'SOME', 'STRINGS']

// Using Vanilla JS (returns a new list)
words.map(toUpper) // returns ['THESE', 'ARE', 'SOME', 'STRINGS']

words // still ['these', 'aRe', 'Some', 'strINGS']
```

Look, ma! No loops!

### filter

The `filter` function takes a function and a list, applies the function to each item in the list, and includes in the output only those items for which the function applied to that item returns `true`.

```javascript
import { filter } from 'ramda'

function isEven (num) {
  return num % 2 === 0
}

const someNumbers = [1, 3, 4, 6, 7, 8, 9]

// Return a list of only the even numbers
filter(isEven, someNumbers) // returns [4, 6, 8]

// Using Vanilla JS (returns a new list)
someNumbers.filter(isEven) // returns [4, 6, 8]

someNumbers // still [1, 3, 4, 6, 7, 8, 9]
```

### find

The `find` function takes a function and a list, applies the function to each item in the list in turn, and returns the _first item_ for which the function when applied to it returns `true`:

```javascript
import { find } from 'ramda'

function moreThanFive (x) {
  return x > 5
}

const possibles = [1, 2, 4, 6, 9]

// Find the first item greater than five
find(moreThanFive, possibles) // returns 6

// Using Vanilla JS
possibles.find(moreThanFive) // returns 6
```

Easy peasy, right?

### reduce

The `reduce` function takes **three** parameters and can return just about anything! This is the most powerful of our functions, and can replace almost any loop. In fact, we can make any of the other functions here&mdash;`map`, `filter`, `find`, etc.&mdash;using the `reduce` function, so you can consider those functions really just sugar on top of `reduce`.

The first parameter of the `reduce` function is a function, similar to `map`, `filter`, and `find`, and the _third_ parameter is the list we're going to operate on, again, similar to `map`, `filter`, `find`, etc. The special extra parameter is the middle one. It is the "accumulator" because as we loop through the items in the list provided as the third argument, we are going to use this accumulator to build our final result.

This is much easier done than said! One common use for `reduce` (as the name implies) is to take a list and combine the terms in some way, perhaps by adding them up. So suppose I wanted to add a list of numbers. In this instance, you can think of the accumulator as the "running total". So, naturally, we start with 0:

```javascript
import { reduce } from 'ramda'

const numbersToSum = [5, 10, 15, 20]

reduce(
  function (total, num) { return total + num },
  0,
  numbersToSum
) // returns 50 (0 + 5 + 10 + 15 + 20)

// Using Vanilla JS
numbersToSum.reduce((total, num) => total + num, 0)

// `(total, num) => total + num` is a shorter way to write
// `function (total, num) { return total + num }` -- see "arrow functions"
```

What is happening here? It's very simple! The `reduce` function takes the list in the third argument&mdash;`[5, 10, 15, 20]`&mdash;and loops through it. For each item in the list is calls the function in the first argument&mdash;`function (total, num) { return total + num }`&mdash; and it passes it the _running total_ (starting with the second argument, 0) and the item from the list.

The function adds the running total (`total`) to the item (`num`) and returns the new total, _which is passed as the `total` when the function is called on the next item. So this function is called four times. Our anonymous function just takes two numbers and adds them together, so we can use the `ramda` `add` function just as easily:

```javascript
import { add, reduce } from 'ramda'

reduce(add, 0, [5, 10, 15, 20])

// is the same as doing

add(0, 5) // returns 5
add(5, 10) // returns 15
add(15, 15) // returns 30
add(30, 20) // returns 50

// the first argument is the running total, and the second is the next item in the list
```

But `reduce` can do so much more. Let's recreate our `map`, `filter`, and `find` functions using `reduce`.

First, `map`:

```javascript
import { reduce } from 'ramda'

function map (f, list) {
  return reduce(
    (acc, item) => [...acc, f(item)],
    [],
    list
  )
}

map(x => x * x, [1, 2, 3]) // returns [1, 4, 9]
```

Take a close look at our function, `(acc, item) => [...acc, f(item)]`. This is the same as this: `function (acc, item) { return [...acc, f(item)] }`. Here is what that looks like as it runs:

```javascript
// First item
([], 1) => [...[], 1 * 1] // ...[] spreads to nothing, and 1 * 1 === 1, so the return is [1]

// Second item
([1], 2) => [...[1], 2 * 2]  // ...[1] spreads to 1, and 2 * 2 === 4, so the return is [1, 4]

// Last item
([1, 4], 3) => [...[1, 4], 3 * 3] // ...[1, 4] spreads to 1, 4, and 3 * 3 === 9, so the return is [1, 4, 9]
```

Really not difficult. We are taking our "accumulator" (which can be anything) and modifying it on each call to the function, then returning the modified accumulator which is the first argument to the _next_ call to the function. Build the output one function call at a time, _just like in a loop_.

Now what about `filter`?

```javascript
import { reduce } from 'ramda'

function filter (f, list) {
  return reduce(
    (acc, item) => f(item) ? [...acc, item] : acc,
    [],
    list
  )
}

filter(n => n % 2 === 0, [1, 2, 3, 4, 5]) // returns [2, 4]
```

Same as map, but this time we are using the function `f` to check each item in the list. If `f(item)` returns `true`, then we include that item in the new array: `[...acc, item]`. If it returns `false`, then we return the new array unchanged: `acc`. If `acc` (for "accumulator") is confusing, then call it `out` or `output` or `filteredListSoFar` or whatever makes sense to you.

Note: `n => n % 2 === 0` is the same as `function (n) { return n % 2 === 0 }`. It takes a number, divides it by 2 and takes the remainder and then compares that to 0. If the remainder is 0, then it returns `true` (the number is even). If it is anything but 0 (which could only be 1 in this instance), then it returns `false` because the number is not even.

The "ternary operator" (`?:`) returns the second term (`[...acc, item]`) if the first term (`f(item)`) returns "truthy", or the third term (`acc`) if it returns anything other than "truthy".

OK, `find`:

```javascript
import { reduce } from 'ramda'

function find (f, list) {
  return reduce(
    (acc, item) => acc === undefined && f(item) ? item : acc,
    undefined,
    list
  )
}
```

This works similarly to `filter`, but when we start with our accumulator undefined. For each item in the list, if the accumulator has yet to be defined and the `f(item)` returns `true`, we return the item. If the accumulator is already filled or the `f(item)` returns `false`, then we return the accumulator unchanged.

This is not the ideal way to write this function as the loop continues all the way to the end, even if we find the item in the first spot. Later in this tutorial we'll show you a better way to implement the `find` function (not that you'll ever actually have to...).

We could also use `reduce` to map through an object. For example, here we want to convert the values of each key-value pair to uppercase:

```javascript
import { keys, reduce, toUpper } from 'ramda'

const colours = {
  red: 'f00',
  yellow: 'ff0',
  green: '0f0',
  cyan: '0ff',
  blue: '00f',
  magenta: 'f0f'
}

/* Returns
  {
      blue: "00F",
      cyan: "0FF",
      green: "0F0",
      magenta: "F0F",
      red: "F00",
      yellow: "FF0"
  }
 */
reduce(
  (acc, key) => ({
    ...acc, // copy the current accumulator
    [key]: toUpper(colours[key]) // overwrite the value of `key` with the uppercase value of `key`
  }),
  {}, // our starting accumulator: will contain the uppercased key-value pairs when we're done
  keys(colours) // an array of just the keys in `colours`
)

// Using Vanilla JS
Object.keys(colours).reduce((acc, key) => ({...acc, [key]: colours[key].toUpperCase() }), {})
```

### join

The `join` function takes an array of strings and joins them together inserting a separator between individual items. The first parameter is the separator; the second parameter is the array of strings to join (unless you're using the `join` method on the array itself, as in the Vanilla JS version):

```javascript
import { join } from 'ramda'

const colours = ['red', 'green', 'blue']

join(' / ', colours) // returns 'red / green / blue'

// Using Vanilla JS
colours.join(' / ') // returns 'red / green / blue'
```

### sort

The `sort` function takes a comparator function and a list and sorts the items in the list using the comparator function. The comparator  function should return a negative number if the first value is comes first, a positive number if it comes second, and zero if it doesn't matter (e.g., they're equal). So if we wanted to sort a list of numbers in _descending_ order, we could do it this way:

```javascript
import { sort } from 'ramda'

function compare (a, b) {
  return b - a
}

const nums = [5, 1, 4, 2, 3]

sort(compare, nums) // returns [5, 4, 3, 2, 1]

// Using Vanilla JS
nums.sort(compare) // returns [5, 4, 3, 2, 1]
```

If we use our `compare` function on the first two numbers, 5 and 1, we can see that it returns -4: `compare(5, 1) // 1 - 5 === -4`. We said that a negative number means the first value goes first, so that means the 5 comes before the 1. On the other hand, comparing the 1 and the 4&mdash;`compare(1, 4) // 4 - 1 === 3`&mdash;returns a positive number, so the _second_ number (4) comes first. And so on.

What if we want to sort in ascending order? Just change the compare function: `(a, b) = a - b`.

How does this work internally? Who cares? It works. If sorting algorithms are your thing, feel free to look at the source code. But to use `sort`, you don't "need to know".

**Note that all of these functions _return copies_ of the original list (or a new value entirely). None of them mutate the original list in place. If you started with an array, e.g., `[1, 2, 3]`, then after you've run one of these functions on it, the original array _is still_ `[1, 2, 3]`.** That's very important.

## Rule 4

**Avoid loops! You can also create a function that calls itself over and over again.**

We used `reduce` to define a `find` function above, but we said it was less than optimal because it ran through the entire list, even if it found the item it was looking for on in the first spot.

There is another way to implement the `find` function without a loop. We can create a function that looks in the first spot, and if it finds the item we're looking for, then it returns it and _we're done_. No need to loop through the remaining items.

But what if the first item is not the one we're looking for? Easy! In that instance, we'll just _call the find function again with **the rest of the list**_. Meaning, we'll take the "tail" of the list (all the items except the first, "head" item), and call our `find` function on it _from inside our `find` function_. Sounds crazy, but it's very simple in practice. Here's our `find`:

```javascript
function find (f, [x, ...xs]) {
  return f(x)
    ? x
    : find(f, xs)
}

find(n => n > 3,  [2, 4, 6]) // returns 4
```

So what's happening here? Simple: `find` takes a function that returns `true` or `false` and a list of items. We call the function on the first item, and if it returns `true` then we return that item from `find`. If it returns `false`, then we move on to the next item.

The `[x, ...xs]` trick is a common one in JS. It "destructures" our array into a "head" (`x`), which is a single item, and a "tail" (`xs`), which is the rest of the array. Remember: `x` is an **item** in the array, and `xs` is an **array of items**. Very different things! The `x` and `xs` terminology is common, with `x` being an item and `xs` being "the rest of the items". We could as easily have called them `head` and `tail`, or `firstItem` and `remainingItems`, but `x` and `xs` are so common in functional programming that everyone understands what we mean.

Inside the function, we use a ternary operator again. First we apply the function `f` to the first item (head) `x`. If it returns `true` (or truthy), then we return `x` and we're done. If it returns `false` (or falsy), then _we call `find` again and pass it the remaining items:_ `find(f, xs)`.

You may have noticed a problem here. What if we call our `find` on a list that _does not contain what we're looking for?_ If you try it, you'll get an error that says "Maximum call stack size exceeded" or something like that. This is because our `find` function doesn't know when to stop looking! It keeps calling itself even though the list is empty. We can't have that.

All functions that call themselves like this must have a "base case" that stops them from looping infinitely, _and each time the function is called, it must get **closer** to the base case_. In other words, it does no good to have a base case that says "stop if the argument is zero" if my function is _adding_ numbers: I'll never get there.

When our list is empty, `x` will be undefined. So we could add a guard clause to stop the loop when `x` is undefined, or we could just add it to our condition in the ternary:

```javascript
function find (f, [x, ...xs]) {
  return x === undefined || f(x)
    ? x
    : find(f, xs)
}

find(n => n > 3,  [1, 2, 3]) // returns undefined
```

(Note: this won't work on an array with some items undefined, but that's probably OK for our purposes. If we have to permit undefined values in the array, we could use the array length instead and stop when it is empty.)

This kind of function can pile up calls on the stack (memory) until it finally returns, so don't use it for functions that will operate on lists so long that you're likely to run out of memory or suffer a big performance hit. But for most instances where you are looping through only a few (or a few hundred) items, it's probably fast enough. For the others, prefer the functions such as `map`, which are optimised.
